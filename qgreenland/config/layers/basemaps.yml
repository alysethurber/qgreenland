# What about combining id, name, group_path in to one triple-duty unique
# identifier? One problem with this is coupling the group path with the unique
# identifier -- you have to change the identifier to change the groups a layer is
# shown in on the QGIS layers panel. e.g.:
#     - layer: 'Basemaps/Background (500m)'

- id: 'background'  # The on-disk folder containing the data
  title: 'Background (500m)'  # The layer name in the QGIS panel
  # TODO: originally called 'group_path', but that's a confusing name. Do we like 'hierarchy'?
  hierarchy: ['Basemaps']  # The group(s, if nested) in the QGIS panel that this layer is in
  in_package: True
  show: True  # Whether this layer is "shown" in QGIS
  # TODO: Make "input" into a "step"? i.e.:
  # - fetch:
  #     dataset: 'background'
  #     asset: 'high_res'
  input:
    dataset: 'background'
    asset: 'high_res'
  steps:
    # Extract the data
    - command: ['unzip', '{input_dir}/*.zip', '-d', '{output_dir}']

    # Warp the data
    # "cut hack". Instead of doing one warp operation, we break it into two
    # pieces to avoid:
    #
    #     Self-intersection at or near point 21540.002777633181
    #     2999.9999813578638\nERROR 1: Cutline polygon is invalid.\n
    #
    # TODO: Template for the cut hack!
    # TODO: Consider adding a "description" to each step?
    - command:
      - 'gdalwarp'
      - '-t_srs'  # dstCRS
      - 'EPSG:3413'
      - '-tr'  # xRes=500, yRes=500
      - '500'
      - '500'
      - '-te'
      # TODO: Abstract boundaries... as slugs? e.g.:
      #     {boundaries.background.extent['minx']}
      #     {boundaries.background.extent['miny']}
      #     {boundaries.background.extent['maxx']}
      #     {boundaries.background.extent['maxy']}
      - '-5774572.727595 -5774572.727595 5774572.727595 5774572.727595'
      - '-dstnodata'  # dstNodata
      - '0'
      - '-wo'  # warpOptions=['SOURCE_EXTRA=100', 'SAMPLE_GRID=YES']
      - 'SOURCE_EXTRA=100'
      - '-wo'
      - 'SAMPLE_GRID=YES'
      # What about using dedicated keys for `input_file` and `output_file` so
      # the command itself can reference that slug. If either is repeated in
      # the command, this will help avoid mistakes.
      - '{input_dir}/NE2_HR_LC_SR_W/NE2_HR_LC_SR_W.tif'  # <--- Input
      - '{output_dir}/warped.tif'  # <--- Output

    # Cut the data and compress output
    - command:
      - 'gdalwarp'
      - '-cutline'  # CutlineDSName
      # TODO: Abstract boundaries... as slugs? e.g.:
      #     {boundaries.background.filepath}
      - '{assets_dir}/local_data/latitude_shape_40_degrees.geojson'
      - '-crop_to_cutline'  # CropToCutline=True
      - '-co'  # creationOptions=['COMPRESS=DEFLATE']
      - 'COMPRESS=DEFLATE'
      - '{input_dir}/warped.tif'  # <--- Input
      - '{output_dir}/cut.tif'  # <--- Output

    # Add overviews
    - command:
      # TODO: Is this the best solution? gdaladdo can only modify in place.
      # What about rasterio (`rio` at CLI)?
      - 'cp'
      - '{input_dir}/cut.tif'
      - '{output_dir}/overviews.tif'
      - '&&'
      - 'gdaladdo'
      - '-r'
      - 'average'
      - '{output_dir}/overviews.tif'
      - '2'
      - '4'
      - '8'
      - '16'

    # - template:
    #     name: 'warp_multiple_steps'
    #     output_fn: 'foo.tif'
    #     kwargs:
    #       foo: bar
    # - template:
    #     name: 'build_overviews'
    #     output_fn: 'foo.tif'
    #     kwargs:
    #       baz: qux
    # - template:
    #     name: 'compress'
    #     output_fn: 'foo.tif'
    #     kwargs:
    #       banana: manaÃ±a 
